####代理模式
代理对象在客户端和目标对象之间起到中介作用，为其他对象提供一种代理，以控制对这个对象的访问。
代理模式属于结构型设计模式，主要有两个目的：一是保护目标对象，二是增强目标对象。
代理对象持有被代理对象的引用，客户端调用代理对象的方法，同时也调用被代理对象的方法，但是会在代理对象前后增
加一些处理代码。在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。

####CGLib动态代理和Jdk动态代理对比
（1）JDK动态代理实现了被代理对象的接口，CGLib代理继承了被代理对象。
（2）JDK动态代理和CGLib代理都在运行期生成字节码，JDK动态代理直接写Class字节码，
     CGLib代理使用ASM框架写Class字节码，CGlib代理实现更复杂，【生成代理类】比JDK动态代理效率低。
     （这里指的是生成代理类的效率，不是下面的代理方法执行效率）
（3）JDK动态代理调用代理方法是通过反射机制调用的，
     CGLib代理是通过FastClass机制直接调用方法的，CGLib代理的执行效率更高。
     
####Spring中动态代理策略选择原则
（1）当Bean有实现接口时，Spring就会用JDK动态代理。
（2）当Bean没有实现接口时，Spring会选择CGLib代理。
（3）Spring可以通过配置强制使用CGLib代理，只需在Spring的配置文件中加入如下代码：
     <aop:aspectj-autoproxy proxy-target-class="true"/>

####静态代理和动态代理的本质区别
（1）静态代理只能通过手动完成代理操作，如果被代理类增加了【新的方法】，代理类需要同步增加，违背开闭原则；
     当被代理的类新增的时候，也需要重写代理类。
（2）动态代理采用在运行时动态生成代码的方式，取消了【对被代理类的扩展】限制，遵循开闭原则。
（3）若动态代理要【对目标类的增强逻辑进行扩展】，结合策略模式，只需要新增策略类便可完成，无须修改代理类的代码。

####代理模式优缺点
优点：
（1）代理模式能将代理对象与真实被调用目标对象分离。 解耦
（2）在一定程度上降低了系统的耦合性，扩展性好。    扩展性好
（3）可以起到保护目标对象的作用。                 保护目标对象（被代理对象）
（4）可以增强目标对象的功能。                     增强被代理对象
缺点：
（1）代理模式会造成系统设计中类的数量增加。                              增加类的数量
（2）在客户端和目标对象中增加一个代理对象，会导致请求处理速度变慢。        增加代理对象，请求处理速度变慢
（3）增加了系统的复杂度。                                              复杂度



